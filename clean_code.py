import streamlit as st

from utilities.db import db
from firebase_admin import auth
from itertools import chain

from utilities.font_and_styles_handling import check_font_size , check_font_style , check_caption_styles , check_heading_styles , highlight_font_size_error
from utilities.margin_handling import check_margins , highlight_margin_error
from utilities.spacing_handling import check_line_spacing
from utilities.header_footer_handling import check_header_footer_styles , check_text_style , format_header_footer_errors
from utilities.apa_handling import validate_apa_reference , extract_references_from_docx 
from utilities.report import generate_comprehensive_pdf
from utilities.ai_plagiarism import check_ai_plagiarism
from utilities.pagenumber import is_page_number_field , check_page_number_format


import tempfile
import shutil

import docx
import re
import os
from datetime import datetime
from docx.shared import Pt

from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter


# Optional test
doc_ref = db.collection("test").document("check")
doc_ref.set({"message": "connected from Streamlit"})

st.success("✅ Firebase Firestore connected successfully!")
# --- Streamlit Pages --- (Login, Signup, Home, Upload)
def signup_page():
    st.title("Signup")
    username = st.text_input("Email (Username)")
    password = st.text_input("Password", type="password")

    if st.button("Sign Up", key="signup_button"):
        # Enhanced email validation to prevent numeric-only emails
        if not re.match(r"^[a-zA-Z][\w.-]*@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$", username):
            st.error("Please enter a valid email address (e.g., name@example.com).")
            return

        if len(password) < 6:  # Check password length
            st.error("Password must be at least 6 characters long.")
            return

        try:
            user = auth.create_user(email=username, password=password)
            st.success("Account created successfully! You can now log in.")
        except Exception as e:
            st.error(f"Error: {e}")
            print(e)  # Log the error

def login_page():
    st.title("Login")
    username = st.text_input("Email (Username)")
    password = st.text_input("Password", type="password")

    if st.button("Login", key="login_button"):
        if not username or not password:
            st.error("Please enter both email and password.")
            return

        try:
            user = auth.get_user_by_email(username)
            # You can verify the password here if needed, but Firebase handles it automatically
            st.session_state.logged_in = True  # Set the session to logged in
            st.success("Logged in successfully!")
            # Optionally redirect to the home page
            home_page()  # Call the home page function directly after login
        except Exception as e:
            st.error(f"Error: {e}")
            print(e)  # Log the error for debugging

def home_page():
    st.title("Welcome to ADF Check")
    st.write("Go-to tool for document formatting checks and enhancements.")

    if "logged_in" in st.session_state and st.session_state.logged_in:
        if st.button("Start Using ADF Check", key="start_using_adf_check"):
            upload_page()  # Directly call the upload page if logged in
    else:
        st.warning("Please log in first!")
        if st.button("Login", key="home_login_button"):
            login_page()

def upload_page():
    st.header("Upload Your Document")
    uploaded_file = st.file_uploader("Upload your document", type=["docx"])
    instructions = st.text_area("Enter specific instructions")

    if uploaded_file:
        try:
            # Load the Word document
            document = docx.Document(uploaded_file)

            # Extract plain text from document paragraphs
            extracted_text = "\n".join([para.text for para in document.paragraphs])

            # Call AI Plagiarism Detection API
            plagiarism_result = check_ai_plagiarism(extracted_text)

            # Show plagiarism result to the user
            if "error" in plagiarism_result:
                st.error(f"AI Plagiarism Check Error: {plagiarism_result['error']}")
            else:
                real_prob = plagiarism_result.get("real_probability", 0)
                fake_prob = plagiarism_result.get("fake_probability", 0)

                st.subheader("🧠 AI Plagiarism Detection Result")
                st.write(f"**Human-written Probability:** {real_prob:.2%}")
                st.write(f"**AI-generated Probability:** {fake_prob:.2%}")

                if fake_prob > 0.8:
                    st.warning("⚠️ High chance this content was generated by AI.")
                elif real_prob > 0.8:
                    st.success("✅ This content is most likely human-written.")

        except Exception as e:
            st.error(f"Error reading document: {e}")

    if st.button("Upload and Check Document", key="upload_button"):
        if uploaded_file:
            try:
                # Open the uploaded document
                document = docx.Document(uploaded_file)
                
                # Perform your existing checks
                font_size_errors = check_font_size(document)
                font_style_errors = check_font_style(document)
                caption_style_errors = check_caption_styles(document)
                heading_style_errors = check_heading_styles(document)
                margin_errors = check_margins(document)
                line_spacing_errors = check_line_spacing(document)
                header_footer_errors = check_header_footer_styles(document)
                apa_references = extract_references_from_docx(uploaded_file)
                check_page_number_format =is_page_number_field
                apa_errors = [f"\u274C Reference {i+1}: '{ref}' is not in APA format." for i, ref in enumerate(apa_references) if not validate_apa_reference(ref)]
                
                # Create structured error list with section headers
                all_errors = []
                check_page_number_format =[]
                all_errors += ["Font Size Errors"] + font_size_errors
                all_errors += ["Font Style Errors"] + font_style_errors
                all_errors += ["Table & Figure Caption Errors"] + caption_style_errors
                all_errors += ["Heading Style Errors"] + heading_style_errors
                all_errors += ["Line Spacing Errors"] + line_spacing_errors
                all_errors += ["Header & Footer Errors"] + header_footer_errors
                all_errors += ["Margin Errors"] + margin_errors
                all_errors += ["Reference Errors"] + apa_errors
                check_page_number_format += ["is_page_number_field"] + check_page_number_format
                
                

                # Generate PDF report
                report_path = generate_comprehensive_pdf(all_errors)

                # Highlight the document with errors
                highlighted_doc_path = "document_with_errors_highlighted.docx"
                # Save the highlighted document
                document.save(highlighted_doc_path)

                st.success("Validation Completed!")

                # PDF download button
                with open(report_path, "rb") as pdf_file:
                    st.download_button(
                        label="Download Validation Report",
                        data=pdf_file,
                        file_name="ADF_Validation_Report.pdf",
                        mime="application/pdf"
                    )

                # Highlighted document download button
                with open(highlighted_doc_path, "rb") as docx_file:
                    st.download_button(
                        label="Download Highlighted Document",
                        data=docx_file,
                        file_name="document_with_errors_highlighted.docx",
                        mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                    )
            except Exception as e:
                st.error(f"Error: {e}")
        else:
            st.warning("No file uploaded.")
            
def logout_page():
    if st.button("Logout", key="logout_button"):
        st.session_state.logged_in = False
        st.success("Logged out successfully!")
        
def cleanup_temp_files():
    temp_dir = tempfile.gettempdir()
    for filename in os.listdir(temp_dir):
        if filename.startswith("ADF_Report_"):
            file_path = os.path.join(temp_dir, filename)
            try:
                os.remove(file_path)
            except Exception as e:
                print(f"Error deleting temp file {file_path}: {str(e)}")

def main():
    st.sidebar.title("ADF Check")
    pages = ["Home", "Upload", "Login", "Signup"]
    selected_page = st.sidebar.selectbox("Select a page", pages)

    if selected_page == "Home":
        home_page()
    elif selected_page == "Upload":
        upload_page()
    elif selected_page == "Login":
        login_page()
    elif selected_page == "Signup":
        signup_page()
    elif selected_page == "logout":
        logout_page()

if __name__ == "__main__":
    main()